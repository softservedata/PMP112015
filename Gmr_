#pragma once
class MatrixGraph
{
private:
	bool **graph;
	int vertexNumber;
public:
	MatrixGraph() {};
	MatrixGraph(int n);
	~MatrixGraph();
	int CountVErtex()
	{
		return vertexNumber;
	}
	MatrixGraph operator+(MatrixGraph&MG)
	{
		MatrixGraph g_graph(vertexNumber + 1);
		for (int i = 0; i < this->vertexNumber; i++)
			for (int j = 0; j < this->vertexNumber; j++)
			{
				g_graph.graph[i][j] = this->graph[i][j];
			}
		return g_graph;
	}
	void delArc(int, int);
	void AddArc(int from, int to);
	bool HasArc(int from, int to);
};

/////////////////////////////////

#include "Header.h"
#include"iostream"
#include"cstring"

using namespace std;
MatrixGraph::MatrixGraph(int n)
{
	graph = new bool*[vertexNumber = n];
	for (int i = 0; i < n; i++)
	{
		bool*row = graph[i] = new bool[n];
		for (int j = 0; j < n; j++)
		{
			row[j] = false;
		}
	}
	//cout << "constructur with 'n' DONE" << endl;
}
void MatrixGraph::delArc(int from, int to)
{
	graph[from][to] = 0;
}
void MatrixGraph::AddArc(int from, int to) {
	if (from < 0 || from >= vertexNumber || to < 0 || to >= vertexNumber)
		return;
	graph[from][to] = true;
	//cout << "ADDARC done!" << endl;
}
bool MatrixGraph::HasArc(int from, int to)
{
	if (from < 0 || from >= vertexNumber || to < 0 || to >= vertexNumber)
	{
		cout << "False" << endl;
	}
	//cout << "has arc DONE!" << endl;
	return graph[from][to];
}
MatrixGraph::~MatrixGraph()
{
	for (int i = 0; i < vertexNumber; i++)
	{
		delete graph[i];
	}
	delete graph;
	//cout << "destructor DONE !" << endl;
}

/////////////////////////////////////////

#include"iostream"
#include"Header.h"

using namespace std;
void Print(MatrixGraph & g)
{
	int n = g.CountVErtex();
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < n; j++)
		{
			std::cout << (g.HasArc(i, j) ? '1' : '0') << " ";
		}
		std::cout << endl;
	}
}

const int max_size = 6;
struct Stack
{
	private:
		int top;
		int data[max_size];
	public:
		bool Is_Empty();
		void Create_Stack();
		int Push(char x);
		int Pop();	
};

bool Stack::Is_Empty()
{
	return (top == 0);
}

void Stack::Create_Stack()
{
	top = 0;
}

int Stack::Push(char x)
 {
	if (top == max_size)
	{
		std::cout << "Stack Overflov..."; 
		return 0;
	}
	else
	{
		data[top] = x;
		++top;
		return 1;
	}
	
}
int Stack::Pop()
{
	if (Is_Empty())
	{
		std::cout << "Stack is Empty...";
		return 0;
	}
	else
	{
		--top;
	}
}

int main()
{
	setlocale(LC_ALL, "ukr");
	cout << "Введiть к-сть вершин: ";
	int arcc;
	std::cin >> arcc; cout << endl;
	MatrixGraph g_graph(arcc);
	g_graph.AddArc(0, 1);
	g_graph.AddArc(0, 2);
	g_graph.AddArc(1, 0);
	//g_graph.AddArc(2, 0);
	//g_graph.AddArc(1, 2);
	g_graph.AddArc(2, 0);
	//g_graph.AddArc(3, 4);
	g_graph.AddArc(3, 5);
	g_graph.AddArc(2, 5);
	//g_graph.AddArc(3, 5);
	//g_graph.AddArc(3, 2);
	//g_graph.AddArc(4, 3);
	g_graph.AddArc(4, 5);
	g_graph.AddArc(5, 2);
	g_graph.AddArc(5, 3);
	g_graph.AddArc(5, 4);
	g_graph.AddArc(3,4);
	g_graph.AddArc(4,3);
	std::cout << "Graph initialy :" << endl;
	Print(g_graph);


	int kol = 0;
	int antikol = 1;
	const int n = g_graph.CountVErtex();


	int *Z = new int [n];//vershyna y steci
	for (int i = 0; i < n; i++)
	{
		Z[i] = 8;
	}

	Z[0] =n-n;


	const int SIZE = arcc;
	const int max_size = 6;
	int *COPY = new int[SIZE];
	for (int i = 0; i < SIZE; i++)
	{
		COPY[i] = 0;
	}


	Stack C[max_size];
	C[0].Create_Stack();
	C[0].Push(n-n);
	kol++;


	int t = 1; 
	int i = n-n;
	while(t<n && !C[kol-antikol].Is_Empty())
	{
		for (int j = 0; j < n; j++)
		{	
			if (g_graph.HasArc(i, j) == true)
			{ 
				//std::cout << "\nВершина " << j << " сумiжна з вершиною " << i << endl;
				int lich = 0;
				for (int i = 0; i < n; i++)
				{
					if (Z[i] == j)
					{
						lich++;
					 	break;
					}
				}
				if (lich == 0)
				{
					C[kol].Create_Stack();
					C[kol].Push(j);
					Z[kol] = j;
					COPY[kol] = j;
					t++;
					kol++; 
					i = j;
					j = -1; 
				}
				else if (j == n-1 )
				{
					if (!C[kol - antikol ].Is_Empty())
					{
						C[kol - antikol].Pop();
						antikol++;
						for (int r = max_size - 1; r >= 0; r--)
						{
							if (COPY[r] != 9)
							{
								i = COPY[r];
								COPY[r] = 9;
								break;
							}
						}
					}
				}
			}
			else
			{
				if (j == n - 1)
				{
					if (!C[kol-antikol].Is_Empty())
					{
						C[kol - antikol].Pop();
						antikol++;
						for (int r = max_size - 1; r >= 0; r--)
						{
							if (COPY[r] != 9)
							{
								i = COPY[r];
								COPY[r] = 9;
								break;
							}
						}
					}	
				}
			}	
		}
	}
	std::cout << endl;
	cout << "Z: ";
	for (int i = 0; i < max_size; i++)
	{
		cout << Z[i] << " ";
	}
	if (t == n)
	{
		cout << "\n\nГРАФ ЗВ'ЯЗНИЙ!!!\n\n";
	}
	else
	{
		cout << "\n\nГраф НЕ зв'язний!!!\n\n";
	}
	std::cout << endl;
	std::system("pause");
	return 0;
}
